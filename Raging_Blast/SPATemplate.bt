/*****************************************************************************
 * SPATemplate.bt 
 * Dragon Ball Raging Blast 1 / 2 / Ultimate Tenkaichi - SPA file structure definitions
 *
 *****************************************************************************
 * Requirements: 
 *  common-types.bt template made by revel8n
 * 
 * Revision History:
 *  2021/12/09
 *  2021/11/10
 *  2021/07/30
 *
 * Credits:
 *  Ascomods (DC)
 *  HiroTex for his explanations
 *  revel8n for his templates
 */

#include "../common-types.bt"

BigEndian();

SetBackColor(cLtGreen);

local uint32 savePos = 0;
local int64 savedFilePointers[100];

savedFilePointers[0] = 0;

void PushFP(void) { if (savePos < 100) { savedFilePointers[savePos] = FTell(); ++savePos; } }
void PopFP(void) { if (savePos > 0) { --savePos; FSeek(savedFilePointers[savePos]); } }

local int currentColor;

void AlternateColors(int colorA, int colorB) {
    if (currentColor == colorA) {
        currentColor = colorB;
    } else {
        currentColor = colorA;
    }
    SetBackColor(currentColor);
}

struct ptrString(uint32 stringBase)
{
	uint32 offset <format = hex>;
	
	PushFP();
	{
		SetBackColor(cLtYellow);
		FSeek(offset + stringBase);
		string data;
	}
	PopFP();
};

string ptrString_read (ptrString& s)
{
	return s.data;
}

struct SPA_FILE;

struct SPA_HEADER
{
    // 0x00
	uint32 unknown0x00;
	ptrString name(0)  <read = ptrString_read>;
	uint32 unknown0x08;
	float frameCount;
    // 0x10
    uint32 boneCount;
    uint32 maybeStartOffset      <format = hex>;
    uint32 unknown0x18[6]        <format = hex>;
};

typedef union {
    int64 rot;
	local double x, y, z;
} rotation <read = rotationRead, write = rotationWrite>;

string rotationRead( const rotation &r )
{
    string s;
	r.x = (((double)((r.rot & 0x0fffffffffffffff) >> 40) / 0x7ffff) * 90) - 90,
    r.y = (((double)((r.rot & 0x000000ffffffffff) >> 20) / 0x7ffff) * 90) - 90;
    r.z = (((double)(r.rot & 0x00000000000fffff) / 0x7ffff) * 90) - 90;

    SPrintf( s, "(%e, %e, %e)", r.x, r.y, r.z );
	return s;
}

int64 getRotation(const double &v) {
    return (int64)(((v + 90) * 0x7ffff) / 90);
}

void rotationWrite( rotation &r, string s )
{
    SScanf( s, "(%lf, %lf, %lf)", r.x, r.y, r.z );
    local int64 rotX = getRotation(r.x) << 40;
    local int64 rotY = getRotation(r.y) << 20;
    local int64 rotZ = getRotation(r.z);

    r.rot = 0x3000000000000000 | (rotX | rotY | rotZ);
}

// float4 parsing functions
string float4SciRead( const float4 &v )
{
	string s;   
	SPrintf( s, "(%14e, %14e, %14e, %14e)", v.v[0], v.v[1], v.v[2], v.v[3] );
	return s;
}

typedef struct(int64 baseOffset)
{
	// 0x00
    ptrString name(0)    <read = ptrString_read>;
    uint32 unknown0x04;
    uint32 translationBlockCount;
	uint32 rotationBlockCount;
    // 0x10
    uint32 unknown0x10;     // always null
    uint32 translationFrameOffset    <format = hex>;
    uint32 rotationFrameOffset       <format = hex>;
    uint32 unknown0x1C;     // always null
    // 0x20
    uint32 translationFloatOffset    <format = hex>;
    uint32 rotationFloatOffset       <format = hex>;
    uint32 unknown0x28[2]            <format = hex>;

	if (translationBlockCount > 0)
	{   
	    PushFP();
	    {
            FSeek(translationFrameOffset);
    
            SetBackColor(cPurple);
            float translationFrameData[translationBlockCount] <format = hex>;

            FSeek(translationFloatOffset);

            SetBackColor(cLtGreen);
            float4 translationFloatData[translationBlockCount] <read=float4SciRead>;
	    }
	    PopFP();
    }

	if (rotationBlockCount > 0)
	{   
	    PushFP();
	    {
            FSeek(rotationFrameOffset);

			SetBackColor(0xff56c6);
            float rotFrameData[rotationBlockCount] <format = hex>;

            FSeek(rotationFloatOffset);

			SetBackColor(0xff9f2b);
            rotation rotFloatData[rotationBlockCount];
	    }
	    PopFP();
    }
} BONE_ENTRY <read = readBone>;

string readBone(const BONE_ENTRY &b){
	string s;
	SPrintf(s, "%s", ptrString_read(b.name));
	return s;
}

// SPA File Structure
struct SPA_FILE
{
	SetBackColor(cLtGreen);
	struct SPA_HEADER header;
    
    currentColor = cLtBlue;
	struct
	{
        local int i;
        for(i = 0; i < header.boneCount; i++) {
            AlternateColors(0xbe7aff, 0x8b1eea);
            struct BONE_ENTRY child(startof(parentof(this))) <optimize = false>;
        }
	} boneEntries;
};

struct SPA_FILE fileInfo;
